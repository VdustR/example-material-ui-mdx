{"version":3,"sources":["../node_modules/prismjs/components/prism-jsx.js"],"names":["Prism","javascript","util","clone","languages","jsx","extend","tag","pattern","inside","insertBefore","spread","punctuation","attr-value","script","script-punctuation","alias","rest","stringifyToken","token","content","map","join","hooks","add","env","language","walkTokens","tokens","openedTags","i","length","notTagNorBrace","type","tagName","pop","push","openedBraces","plainText","splice","Token"],"mappings":"8EAAA,SAAAA,GACA,IAAAC,EAAAD,EAAAE,KAAAC,MAAAH,EAAAI,UAAAH,YACAD,EAAAI,UAAAC,IAAAL,EAAAI,UAAAE,OAAA,SAAAL,GACAD,EAAAI,UAAAC,IAAAE,IAAAC,QAAA,4LACAR,EAAAI,UAAAC,IAAAE,IAAAE,OAAA,IAAAD,QAAA,kBACAR,EAAAI,UAAAC,IAAAE,IAAAE,OAAA,cAAAD,QAAA,yDACAR,EAAAI,UAAAC,IAAAE,IAAAE,OAAA,IAAAA,OAAA,0CACAT,EAAAI,UAAAM,aAAA,sBACAC,OAAA,CACAH,QAAA,6CACAC,OAAA,CACAG,YAAA,cACAC,aAAA,SAGGb,EAAAI,UAAAC,IAAAE,KACHP,EAAAI,UAAAM,aAAA,uBACAI,OAAA,CAEAN,QAAA,4CACAC,OAAA,CACAM,qBAAA,CACAP,QAAA,UACAQ,MAAA,eAEAC,KAAAjB,EAAAI,UAAAC,KAEAW,MAAA,wBAEGhB,EAAAI,UAAAC,IAAAE,KAEH,IAAAW,EAAA,SAAAA,EAAAC,GACA,OAAAA,EAIA,kBAAAA,EACAA,EAGA,kBAAAA,EAAAC,QACAD,EAAAC,QAGAD,EAAAC,QAAAC,IAAAH,GAAAI,KAAA,IAXA,IA8EAtB,EAAAuB,MAAAC,IAAA,0BAAAC,GACA,QAAAA,EAAAC,UAAA,QAAAD,EAAAC,UAjEA,SAAAC,EAAAC,GAGA,IAFA,IAAAC,EAAA,GAEAC,EAAA,EAAmBA,EAAAF,EAAAG,OAAmBD,IAAA,CACtC,IAAAX,EAAAS,EAAAE,GACAE,GAAA,EAgCA,GA9BA,kBAAAb,IACA,QAAAA,EAAAc,MAAAd,EAAAC,QAAA,YAAAD,EAAAC,QAAA,GAAAa,KAEA,OAAAd,EAAAC,QAAA,GAAAA,QAAA,GAAAA,QAEAS,EAAAE,OAAA,GAAAF,IAAAE,OAAA,GAAAG,UAAAhB,EAAAC,EAAAC,QAAA,GAAAA,QAAA,KAEAS,EAAAM,MAGA,OAAAhB,EAAAC,QAAAD,EAAAC,QAAAW,OAAA,GAAAX,SAGAS,EAAAO,KAAA,CACAF,QAAAhB,EAAAC,EAAAC,QAAA,GAAAA,QAAA,IACAiB,aAAA,IAISR,EAAAE,OAAA,mBAAAZ,EAAAc,MAAA,MAAAd,EAAAC,QAETS,IAAAE,OAAA,GAAAM,eACSR,EAAAE,OAAA,GAAAF,IAAAE,OAAA,GAAAM,aAAA,mBAAAlB,EAAAc,MAAA,MAAAd,EAAAC,QAETS,IAAAE,OAAA,GAAAM,eAEAL,GAAA,IAIAA,GAAA,kBAAAb,IACAU,EAAAE,OAAA,OAAAF,IAAAE,OAAA,GAAAM,aAAA,CAGA,IAAAC,EAAApB,EAAAC,GAEAW,EAAAF,EAAAG,OAAA,sBAAAH,EAAAE,EAAA,mBAAAF,EAAAE,EAAA,GAAAG,QACAK,GAAApB,EAAAU,EAAAE,EAAA,IACAF,EAAAW,OAAAT,EAAA,MAGAA,EAAA,sBAAAF,EAAAE,EAAA,mBAAAF,EAAAE,EAAA,GAAAG,QACAK,EAAApB,EAAAU,EAAAE,EAAA,IAAAQ,EACAV,EAAAW,OAAAT,EAAA,KACAA,KAGAF,EAAAE,GAAA,IAAA9B,EAAAwC,MAAA,aAAAF,EAAA,KAAAA,GAIAnB,EAAAC,SAAA,kBAAAD,EAAAC,SACAO,EAAAR,EAAAC,UAUAO,CAAAF,EAAAG,UApHA,CAsHC5B","file":"static/js/166.32c80bea.chunk.js","sourcesContent":["(function (Prism) {\n  var javascript = Prism.util.clone(Prism.languages.javascript);\n  Prism.languages.jsx = Prism.languages.extend('markup', javascript);\n  Prism.languages.jsx.tag.pattern = /<\\/?(?:[\\w.:-]+\\s*(?:\\s+(?:[\\w.:-]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s{'\">=]+|\\{(?:\\{(?:\\{[^}]*\\}|[^{}])*\\}|[^{}])+\\}))?|\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}))*\\s*\\/?)?>/i;\n  Prism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/i;\n  Prism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:(\"|')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])*\\1|[^\\s'\">]+)/i;\n  Prism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n  Prism.languages.insertBefore('inside', 'attr-name', {\n    'spread': {\n      pattern: /\\{\\.{3}[a-z_$][\\w$]*(?:\\.[a-z_$][\\w$]*)*\\}/,\n      inside: {\n        'punctuation': /\\.{3}|[{}.]/,\n        'attr-value': /\\w+/\n      }\n    }\n  }, Prism.languages.jsx.tag);\n  Prism.languages.insertBefore('inside', 'attr-value', {\n    'script': {\n      // Allow for two levels of nesting\n      pattern: /=(\\{(?:\\{(?:\\{[^}]*\\}|[^}])*\\}|[^}])+\\})/i,\n      inside: {\n        'script-punctuation': {\n          pattern: /^=(?={)/,\n          alias: 'punctuation'\n        },\n        rest: Prism.languages.jsx\n      },\n      'alias': 'language-javascript'\n    }\n  }, Prism.languages.jsx.tag); // The following will handle plain text inside tags\n\n  var stringifyToken = function stringifyToken(token) {\n    if (!token) {\n      return '';\n    }\n\n    if (typeof token === 'string') {\n      return token;\n    }\n\n    if (typeof token.content === 'string') {\n      return token.content;\n    }\n\n    return token.content.map(stringifyToken).join('');\n  };\n\n  var walkTokens = function walkTokens(tokens) {\n    var openedTags = [];\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      var notTagNorBrace = false;\n\n      if (typeof token !== 'string') {\n        if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n          // We found a tag, now find its kind\n          if (token.content[0].content[0].content === '</') {\n            // Closing tag\n            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n              // Pop matching opening tag\n              openedTags.pop();\n            }\n          } else {\n            if (token.content[token.content.length - 1].content === '/>') {// Autoclosed tag, ignore\n            } else {\n              // Opening tag\n              openedTags.push({\n                tagName: stringifyToken(token.content[0].content[1]),\n                openedBraces: 0\n              });\n            }\n          }\n        } else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n          // Here we might have entered a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces++;\n        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n          // Here we might have left a JSX context inside a tag\n          openedTags[openedTags.length - 1].openedBraces--;\n        } else {\n          notTagNorBrace = true;\n        }\n      }\n\n      if (notTagNorBrace || typeof token === 'string') {\n        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n          // Here we are inside a tag, and not inside a JSX context.\n          // That's plain text: drop any tokens matched.\n          var plainText = stringifyToken(token); // And merge text with adjacent text\n\n          if (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n            plainText += stringifyToken(tokens[i + 1]);\n            tokens.splice(i + 1, 1);\n          }\n\n          if (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n            plainText = stringifyToken(tokens[i - 1]) + plainText;\n            tokens.splice(i - 1, 1);\n            i--;\n          }\n\n          tokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n        }\n      }\n\n      if (token.content && typeof token.content !== 'string') {\n        walkTokens(token.content);\n      }\n    }\n  };\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    if (env.language !== 'jsx' && env.language !== 'tsx') {\n      return;\n    }\n\n    walkTokens(env.tokens);\n  });\n})(Prism);"],"sourceRoot":""}