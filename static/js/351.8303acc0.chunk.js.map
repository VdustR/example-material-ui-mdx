{"version":3,"sources":["../node_modules/prismjs/components/prism-xquery.min.js"],"names":["r","languages","xquery","extend","xquery-comment","pattern","greedy","alias","string","extension","variable","axis","lookbehind","keyword-operator","keyword","function","xquery-element","xquery-attribute","builtin","number","operator","punctuation","tag","inside","expression","rest","s","e","content","map","join","hooks","add","language","l","t","n","length","a","o","type","tagName","pop","push","openedBraces","i","splice","test","Token","tokens","Prism"],"mappings":"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","file":"static/js/351.8303acc0.chunk.js","sourcesContent":["!function (r) {\n  r.languages.xquery = r.languages.extend(\"markup\", {\n    \"xquery-comment\": {\n      pattern: /\\(:[\\s\\S]*?:\\)/,\n      greedy: !0,\n      alias: \"comment\"\n    },\n    string: {\n      pattern: /([\"'])(?:\\1\\1|(?!\\1)[\\s\\S])*\\1/,\n      greedy: !0\n    },\n    extension: {\n      pattern: /\\(#.+?#\\)/,\n      alias: \"symbol\"\n    },\n    variable: /\\$[\\w-:]+/,\n    axis: {\n      pattern: /(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,\n      lookbehind: !0,\n      alias: \"operator\"\n    },\n    \"keyword-operator\": {\n      pattern: /(^|[^:-])\\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\\b(?=$|[^:-])/,\n      lookbehind: !0,\n      alias: \"operator\"\n    },\n    keyword: {\n      pattern: /(^|[^:-])\\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\\b(?=$|[^:-])/,\n      lookbehind: !0\n    },\n    function: /[\\w-]+(?::[\\w-]+)*(?=\\s*\\()/,\n    \"xquery-element\": {\n      pattern: /(element\\s+)[\\w-]+(?::[\\w-]+)*/,\n      lookbehind: !0,\n      alias: \"tag\"\n    },\n    \"xquery-attribute\": {\n      pattern: /(attribute\\s+)[\\w-]+(?::[\\w-]+)*/,\n      lookbehind: !0,\n      alias: \"attr-name\"\n    },\n    builtin: {\n      pattern: /(^|[^:-])\\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|ENTITIES|ENTITY|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|ID|IDREFS?|int|integer|language|long|Name|NCName|negativeInteger|NMTOKENS?|nonNegativeInteger|nonPositiveInteger|normalizedString|NOTATION|positiveInteger|QName|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\\b(?=$|[^:-])/,\n      lookbehind: !0\n    },\n    number: /\\b\\d+(?:\\.\\d+)?(?:E[+-]?\\d+)?/,\n    operator: [/[+*=?|@]|\\.\\.?|:=|!=|<[=<]?|>[=>]?/, {\n      pattern: /(\\s)-(?=\\s)/,\n      lookbehind: !0\n    }],\n    punctuation: /[[\\](){},;:/]/\n  }), r.languages.xquery.tag.pattern = /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s+[^\\s>\\/=]+(?:=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+))?)*\\s*\\/?>/i, r.languages.xquery.tag.inside[\"attr-value\"].pattern = /=(?:(\"|')(?:\\\\[\\s\\S]|{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}|(?!\\1)[^\\\\])*\\1|[^\\s'\">=]+)/i, r.languages.xquery.tag.inside[\"attr-value\"].inside.punctuation = /^=\"|\"$/, r.languages.xquery.tag.inside[\"attr-value\"].inside.expression = {\n    pattern: /{(?!{)(?:{(?:{[^}]*}|[^}])*}|[^}])+}/,\n    inside: {\n      rest: r.languages.xquery\n    },\n    alias: \"language-xquery\"\n  };\n\n  var s = function s(e) {\n    return \"string\" == typeof e ? e : \"string\" == typeof e.content ? e.content : e.content.map(s).join(\"\");\n  },\n      l = function l(e) {\n    for (var t = [], n = 0; n < e.length; n++) {\n      var a = e[n],\n          o = !1;\n\n      if (\"string\" != typeof a && (\"tag\" === a.type && a.content[0] && \"tag\" === a.content[0].type ? \"</\" === a.content[0].content[0].content ? 0 < t.length && t[t.length - 1].tagName === s(a.content[0].content[1]) && t.pop() : \"/>\" === a.content[a.content.length - 1].content || t.push({\n        tagName: s(a.content[0].content[1]),\n        openedBraces: 0\n      }) : !(0 < t.length && \"punctuation\" === a.type && \"{\" === a.content) || e[n + 1] && \"punctuation\" === e[n + 1].type && \"{\" === e[n + 1].content || e[n - 1] && \"plain-text\" === e[n - 1].type && \"{\" === e[n - 1].content ? 0 < t.length && 0 < t[t.length - 1].openedBraces && \"punctuation\" === a.type && \"}\" === a.content ? t[t.length - 1].openedBraces-- : \"comment\" !== a.type && (o = !0) : t[t.length - 1].openedBraces++), (o || \"string\" == typeof a) && 0 < t.length && 0 === t[t.length - 1].openedBraces) {\n        var i = s(a);\n        n < e.length - 1 && (\"string\" == typeof e[n + 1] || \"plain-text\" === e[n + 1].type) && (i += s(e[n + 1]), e.splice(n + 1, 1)), 0 < n && (\"string\" == typeof e[n - 1] || \"plain-text\" === e[n - 1].type) && (i = s(e[n - 1]) + i, e.splice(n - 1, 1), n--), /^\\s+$/.test(i) ? e[n] = i : e[n] = new r.Token(\"plain-text\", i, null, i);\n      }\n\n      a.content && \"string\" != typeof a.content && l(a.content);\n    }\n  };\n\n  r.hooks.add(\"after-tokenize\", function (e) {\n    \"xquery\" === e.language && l(e.tokens);\n  });\n}(Prism);"],"sourceRoot":""}